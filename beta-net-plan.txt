(0 e 0 (a context state start) Mann-Assign-First-Seat)
(1 i 1 (a ?g guest_name ?n))
(2 x 2 (a count c ?c) Mann-Assign-First-Seat 0 ((#'rete.core/retract context state start) (#'rete.core/asser context state assign_seats) (#'rete.core/asser ?c seating_seat1 1 seating_name1 ?n seating_name2 ?n seating_seat2 1 seating_pid 0 seating_path_done yes) (#'rete.core/asser ?c path_name ?n path_seat 1) (#'rete.core/retract count c ?c) (#'rete.core/asser count c (#'clojure.core/inc ?c)) (#'clojure.core/println (#'clojure.core/str "seat 1 " ?n " " ?n " 1 " ?c " 0 1"))))
(3 e 3 (a context state assign_seats) Mann-Find-Seating)
(4 i 4 (a ?id seating_seat1 ?seat1))
(5 i 5 (a ?id seating_seat2 ?seat2))
(6 i 6 (a ?id seating_name2 ?n2))
(7 i 7 (a ?id seating_pid ?pid))
(8 i 8 (a ?id seating_path_done yes))
(9 i 1 (a ?gst1 guest_name ?n2))
(10 i 9 (a ?gst1 guest_sex ?s1))
(11 i 10 (a ?gst1 guest_hobby ?h1))
(12 i 1 (a ?gst2 guest_name ?g2))
(13 i 9 (a ?gst2 guest_sex ?s2))
(14 i 10 (a ?gst2 guest_hobby ?h1))
(15 i 11 (f ?s1 != ?s2))
(16 i 2 (a count c ?c))
(17 i nil (f true not (#'rete.core/exist ?id path_name ?g2)))
(18 x nil (f true not (#'rete.core/exist ?id choosen_name ?g2 choosen_hobby ?h1)) Mann-Find-Seating 0 ((#'rete.core/retract context state assign_seats) (#'rete.core/asser context state make_path) (#'rete.core/asser ?c seating_seat1 ?seat2 seating_seat2 (#'clojure.core/inc ?seat2) seating_name1 ?n2 seating_name2 ?g2 seating_pid ?id seating_path_done no) (#'rete.core/asser ?c path_name ?g2 path_seat (#'clojure.core/inc ?seat2)) (#'rete.core/asser ?id choosen_name ?g2 choosen_hobby ?h1) (#'rete.core/retract count c ?c) (#'rete.core/asser count c (#'clojure.core/inc ?c)) (#'clojure.core/println (#'clojure.core/str "seat " ?seat2 " " ?n2 " " ?g2))))
(19 e 15 (a context state check_done) Mann-Are-We-Done)
(20 i 16 (a ?ls last_seat ?l_seat))
(21 x 5 (a ?id seating_seat2 ?l_seat) Mann-Are-We-Done 1 ((#'rete.core/retract context state check_done) (#'rete.core/asser context state print_results) (#'clojure.core/println "Yes, we are done!!")))
(22 ex 15 (a context state check_done) Mann-Continue 0 ((#'rete.core/retract context state check_done) (#'rete.core/asser context state assign_seats)))
(23 e 17 (a context state make_path) Mann-Make-Path)
(24 i 7 (a ?id seating_pid ?pid))
(25 i 18 (a ?id seating_path_done no))
(26 i 12 (a ?pid path_name ?n1))
(27 i 19 (a ?pid path_seat ?s))
(28 x nil (f true not (#'rete.core/exist ?id path_name ?n1)) Mann-Make-Path 1 ((#'rete.core/asser ?id path_name ?n1 path_seat ?s)))
(29 e 17 (a context state make_path) Mann-Path-Done)
(30 x 18 (a ?id seating_path_done no) Mann-Path-Done 0 ((#'rete.core/retract context state make_path) (#'rete.core/asser context state check_done) (#'rete.core/retract ?id seating_path_done no) (#'rete.core/asser ?id seating_path_done yes)))
(31 ex 20 (a context state print_results) Mann-All-Done 0 ((#'clojure.core/println "Halt!")))
(32 e 20 (a context state print_results) Mann-Print-Results)
(33 i 5 (a ?id seating_seat2 ?s2))
(34 i 16 (a ?ls last_seat ?s2))
(35 i 12 (a ?id path_name ?n))
(36 x 19 (a ?id path_seat ?s) Mann-Print-Results 1 ((#'rete.core/retract ?id path_name ?n path_seat ?s) (#'clojure.core/println (#'clojure.core/str ?n " " ?s))))
